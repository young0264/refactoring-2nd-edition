## API 리팩터링

- 모듈과 함수는 소프트웨어를 구성하는 블록이고 API는 이 블록들을 서로 연결시켜주는 요소임.
- API를 이해하기 쉽고 사용하기 쉽게 만드는 일은 중요함
- 좋은 API는 데이터를 갱신하는 함수와 그저 조회하는 함수를 명확히 구별함.
    
  ---

- 두 기능이 섞여 있다면 → 질의 함수와 변경 함수 분리하기(11.1)

..

- _

---

## 11.1 질의 함수와 변경 함수 분리하기

### 배경

### 절차

### 예시

---

## 11.2 함수 매개변수화하기

### 배경

- 두 함수의 로직이 유사하고 리터럴 값만 다르다면 그 리터럴 값만 매개변수로 해서 코드의 중복을 제거할 수 있음
- 매개변수의 값만 바꿔서 여러곳에 적용할 수 있어 더욱 유요함

### 절차

1. 비슷한 함수 중 하나를 선택함
2. 함수 선언 바꾸기(6.5절)로 리터럴들을 매개변수로 추가함
3. 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가함
4. 테스트
5. 매개변수로 받은 값을 사용하도록 함수 본문을 수정함
6. 하나 수정할 때마다 테스트
7. 비슷한 다른 함수를 호출하는 곳을 찾아 매개변수화된 함수를 호출하도록 하나씩 수정하고 수정할 때마다 테스트함

### 예시

---

## 11.3 플래그 인수 제거하기

### 배경

- 플래그 인수란(Flag Argument) 호출하는 함수가 호출됟는 함수의 로직을 결정하기 위해 전달하는 매개변수.

  아래의 boolean변수인 isPremium 가 플래스 인수.

- boolean, enum, String 등 다양함
- 함수의 실행을 결정해주는 매개변수라는 점이 포인트
- 개인적으로 플래그 인수를 사용하는 함수를 극도로 싫어함. 함수 호출자의 입장에서 이 매개변수에 어떤 값을 전달해야 하는지 이해하기가 어렵기 때문. → 함수를 이해하기 어려움

```java
public void bookConcert(Customer customer, boolean isPremium) {
    if (isPremium) {
        // 프리미엄 예약용 로직
        ...    
    }    
    else {
        // 일반 예약용 로직
    }
}
```

### 절차

1. 플래그 인수로 실행될 수 있는 흐름들에 대한 함수를 명시적으로 만듦
    - 플래그 인수를 기반으로 깔끔하게 분기되어있다면 조건문 분해하기(10.1절)을 이용해 명시적인 함수들 생성
    - 그렇지 않다면 래핑(Wrapping Function)형태로 만들자.
2. 원래 함수를 호출하는 코드들을 찾아서 명시적인 함수 호출로 바꾸자

### 예시: 매개변수를 까다로운 방식으로 사용할 때

- “isRush가 조건절이 가장 바깥에 있지 않다” → 그 조건이 코드 상단 또는 구조적으로 핵심 분기점이 아니라 여러 if 블록 안에 흩어져 있어서 의도를 파악하기가 힘듦

    ```java
    if (isRush) {
    	// rush인 경우 처리
    } else {
    	// rush가 아닌 경우 처리
    }
    ```


https://github.com/young0264/refactoring-2nd-edition/commit/4f396c8396566e377b4c34f90a9edd6683d09b39

## 11.4 객체 통째로 넘기기

### 배경

- 하나의 레코드에서 값 두어개를 가져와서 인수로 넘기는 코드를 보면 그냥 객체를 통째로 넘기는게 낫지 않은가라는 고민 → 객체 자체를 통째로 넘기면 대응하기 쉬움
- 객체에서 값을 뽑아서 다른 곳에 던진다(넘긴다)는 것 자체가 의미없는 코드를 양산하는 것과 같음(명확성을 떨어트림)
- 매개변수 목록도 짧아지므로 함수를 이해하기가 더 쉬움
- 하지만 함수가 객체 자체에 의존하면 안되는 경우라면, 서로 다른 모듈에 있는 관계라면 이 기법을 사용하지 않음.
- 값 몇개를 꺼내 작업 → 객체로 넘기는게 좋을 수 있음
- 추상화측면에서도 의도를 나타내는 면에서도 그런 편이 더 좋기 때문
- 한편 객체의 일부를 기반으로 같은 동작을 반복하는 코드가 있다면 그 일부가 클래스가 되어야 한다는 뜻. → ‘따로 묶어서 클래스 추출하기’ 적용
- 다른 객체의 메서드를 호출하는 과정에서 자신이 가지고 있는 메서드 여러개를 전달하는 경우라면, 그 객체 자체를 넘기는 경우, 즉 this를 통해 넘기는 경우가 더 나을 수 있음. 이런 기법도 있음.

### 절차

1. 매개변수를 원하는 형태로 빈 함수로 만듦(이후 이름 변경)
2. 새 함수의 본문에서는 원래 함수를 호출하도록 만듦. 매핑하도록 하면 됨
3. 정적 검사를 수행함
4. 모든 호출자가 새 함수를 호출하도록 만듦
5. 호출자를 모두 수정했다면 원래 함수를 인라인(6.2)함
6. 새 함수의 이름을 적절히 수정하고 모든 호출자에 반영함

### 예시

https://github.com/young0264/refactoring-2nd-edition/commit/b38e6b73b305f567fb6ecd1f6bf2926bc77eb02a

---

## 11.5 매개변수를 질의 함수로 바꾸기

### 배경

- 매개변수 목록은 함수의 동작에 영향을 줄 수 잇는 요소들.
- 매개변수 목록은 중복이 없고 짧을수록 좋음.
- 피호출 함수가 스스로 매개변수의 값을 알거나 구할 수 있는 경우라면 없는게 코드이해하기 더 쉬움. 이런 경우는 의미없는 코드.
- 피호출자가 주체가 되도록 함
    - 피호출자 함수에 의도치 않은 의존성이 생기는지 여부가 중요
    - 다른 모듈에 있는 객체를 매개변수로 받지않고 스스로 알아내려고 하면 불필요한 의존성이 생김

      → 해당 함수가 알면 안되는 변수는 매개변수를 삭제하면 안됨

- 그렇다고 매개변수를 없애는 대신 전역변수 같은 걸 이용하려고 하진 말기.

  → 함수는 **참조 투명(referential transparency)**해야함

    - **참조 투명**이란? : 동일한 입력값에 대해 항상 동일한 결과를 반환

### 절차

1. 필요하다면 대상 매개변수를 계산하는 코드를 별도의 함수로 추출
2. 함수 본문에서 대상 매개변수로의 참조를 새로 추출한 함수 호출로 변경
3. 함수 선언 바꾸기(6.5절)로 대상 매개변수를 없애기.

### 예시

https://github.com/young0264/refactoring-2nd-edition/commit/2428ed45ae2745980f3b5a78f6893ac50b36156a

---

## 11.6 질의 함수를 매개변수로 바꾸기

### 배경

- 함수 안에 있기에는 적합하지 않은 참조들을 매개변수로 바꿈으로써 해결
- 함수를 설계할 땐 참조 투명성이 중요함.

  →  참조 투명성이 있는 함수는 매개변수에선 똑같은 동작을 하기 때문에 예측하기가 쉽기때문

- 함수를 호출하는 호출자에게 책임을 옮김(함수를 호출하는 쪽에 책임 전가)

  → 피호출자 함수가 담긴 클래스는 의존성을 없앨 수 있음. 필요하지 않는 의존성을 없앨 수 있어 때로는 불변의 특성을 갖기도 함


### 절차

1. 변수 추출하기(6.3절)로 질의 코드를 함수 본문의 코드와 분리함
2. 함수 본문 중 해당 질의를 호출하지 않는 코드들을 별도의 함수로 추출함
3. 방금 만든 변수를 인라인해서 제거함
4. 원래 함수도 인라인함
5. 새 함수 이름을 원래 함수의 이름으로 변경한다.

### 예시

https://github.com/young0264/refactoring-2nd-edition/commit/5b8ec68274cd730f73ed7659e64d278eefe4e161

---

## 11.7 세터 제거하기

### 배경

- 세터 메서드 존재 → 객체가 변경될 여지가 있다를 의미함
- 객체 생성 후에 변경되지 않을 것이라고 설계한 불변 객체라면 세터 메서드를 없애는게 맞음.
- 즉 수정하지 않겠다 라는 의도를 드러내는 것.!(ex: java의 record)
- 생성자 내에서 setter를 쓰는 경우 → setter 제거 후 생성자를 이용하는게 더 좋음

### 절차

1. 설정해야 할 값을 생성자에서 받지 않는다면 그 값을 생성자에서 매개변수로 받도록 함(생성자로 생성되게)
2. 생성자 밖에서 세터를 호출하는 코드를 모두 찾아서 제거하고 새로운 생성자를 쓰도록 함
3. 세터 메서드를 인라인함
4. 테스트

### 예시

https://github.com/young0264/refactoring-2nd-edition/commit/16ae525c86df6f54d9a5c0154987248d13c9e5dc

---

## 11.8 생성자를 팩터리 함수로 바꾸기

`.. 이걸로 얘기해 보는게 좋을 것 같은데 with 코드`

### 배경

- 많은 객체 지향 언어에서는 생성자를 사용함 (객체를 초기화하는 용도)

[java 기준]

- 생성자는 그 객체의 인스턴스를 반환함. 서브 클래스나 프록시를 반환하지 못한다는 점이 있음.
- 생성자 메서드의 이름보다 더 적절한 이름이 있다고 판단되더라도 그 이름을 사용할 수 없음
- 또 생성자를 호출하려면 특별한 연산자 new 키워드(일반적)를 사용해야해서 ㅇ리반적인 함수를 기대하는 자리에서는 사용할 수 없음.
- 팩터리 함수는 이런 제약이 없는데 팩터리 함수에선 생성자를 써도되고 다른 함수로 대체해도 되기 때문

### 절차

1. 팩터리 함수를 만듦.
2. 생성자를 호출하던 코드를 팩터리 함수로 대체함
3. 하나씩 수정할 때마다 테스트함
4. 생성자의 가시 범위를 최소화하기

### 예시

https://github.com/young0264/refactoring-2nd-edition/commit/815d6c5f6bb38be7dcf47bff38e0ab6da4851512

---

## 11.9 함수를 명령으로 바꾸기

### 배경

- 함수는 프로그래밍의 가장 기본적인 빌딩 요소임
- 함수는 그 함수만을 위한 객체로 캡슐화 되면 종종 유용해지는 상황이 생김.
- 이런 객체를 가리켜서 명령 객체, 함수를 명령 함수라고 함.(디자인 패턴의 Command Pattern 과도 같으며 명령이란 말은 객체의 상태를 변경하는 메서드임)
- 명령 객체 대부분은 메서드 하나로 구성되고 이 메서드를 요청해서 실행하는 것이 이 객체의 목적
- 명령은 평범한 함수 매커니즘보다 훨씬 유연함을 제공해줄 수 있음. Undo 연산 제공 or 라이프 사이클 세밀하게 제어.
- 메서드와 필드를 이용해 복잡한 함수를 쪼개기.

### 절차

1. 대상 함수의 기능을 옮길 빈 클래스 생성. 클래스 이름은 함수 이름에 기초함.
2. 방금 생성한 빈 클래스로 함수를 옮김

   (리팩터링이 끝날 때 까지는 함수를 클래스에서 함수 호출로 바꾸자. 함수 이름은 규칙이 따로 없다면 `execute`나 `call`로 짓자)

3. 함수의 인수들 중 필드로 가질 것들을 생성자로 옮긴다.

### 예시

https://github.com/young0264/refactoring-2nd-edition/commit/738a95edbb3d86df43fd5b14fcd394e737afeb44

---

## 11.10 명령을 함수로 바꾸기

### 배경

- 명령 객체의 장점?

  → 복잡한 연산을 수행하도록 개체 안에서 캡슐화를 할 수 있다는 점

- 복잡한 함수 자체가 객체가 가진 필드들로 인해서 쪼개질 수 있다라는 점이 가장 큼
- 하지만 함수 자체가 복잡하지 않다라고 한다면 명령 객체를 사용한다는 점 자체가 더 복잡할 수 있음

### 절차

1. 명령을 생성하는 코드와 명령 실행 함수를 하나의 함수로 추출함
2. 명령의 보조 함수들을 각각 인라인
3. 함수 선언 바꾸기를 통해 생성자의 매개변수들을 모두 명령의 파라미터로 바꿈
4. 명령 실행 메서드에서 필드를 사용하는 부분에서 파라미터를 사용하는 부분으로 바꿈
5. 생성자 호출과 명령의 실행 메서드 호출을 대체 함수 안으로 인라인
6. 테스트
7. 죽은 코드 제거

### 예시

https://github.com/young0264/refactoring-2nd-edition/commit/eeee1e608541bb44303c50cee155685b7c6d64ad

---

## 11.11 수정된 값 반환하기

### 배경

데이터가 어떻게 수정되는지 코드에서 추적하는 일은 어려움.

그것을 도와주는 방법 중 하나로 함수가 객체의 한 상태만을 변경시킨다면, 그 변경된 값을 리턴하도록해서 외부로 드러나도록 해서 어떻게 수정되는지 추적하기 쉽게 하는 방법이 있음.

### 절차

1. 함수가 수정된 값을 반한하게 하고 호출자가 그 값을 변수로 담도록 함
2. 테스트
3. 피호출함수 안에 반환할 값을 가리키는 새로운 변수를 선언함
4. 테스트
5. 계산이 선언과 동시에 이뤄지도록 통합
6. 테스트
7. 피호출 함수의 변수 이름을 새 역할에 어울리도록 바꿈
8. 테스트

### 예시

https://github.com/young0264/refactoring-2nd-edition/commit/e4b32e8c2fd04447f0f8d8d488b265a60ff56575

---

## 11.12 오류 코드를 예외로 바꾸기

### 배경

오류 코드를 사용한다면 오류 코드를 일일히 검사해서 처리해줘야함.

예외는 예외를 던지면 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 위로 전파됨

프로그램에서 적절한 지점에서 예외를 처리하도록 해놨다면 프로그램은 예외가 생기는 것에 대해서 신경쓰지 않아도 됨. 예외 처리는 정교해야함.

예외를 사용할 땐 예외가 나서 프로그램이 종료되더라도 프로그램이 정상적으로 동작할 것인지에 대한 물음.

예외를 사용해 처리하거나, 오류를 잡아서 검출하거나(?)

### 절차

1. 콜스택 상위에서 예외를 처리할 예외 핸들러 생성
2. 테스트
3. 정적검사 수행
4. catch에서 직접 처리할 수 있는 예외는 적절히 대처하고 그렇지 않으면 throw
5. 테스트
6. 오류 코드를 반환하는 곳에서 예외를 던짐
7. 모두 수정했으면 오류 코드를 콜스택 위로 던지는 코드를 모두 제거

### 예시

---

## 11.13 예외를 사전확인으로 바꾸기

### 배경

- 예외를 던지기 전에 호출자가 예외가 일어날 상황을 미리 감지하고 사전에 대처할 수 잇다면 그렇게 하는게 좀 더 직관적.(예외 던지고 catch에서 처리하는 것보다)

### 절차

1. 예외를 유발하는 코드를 검사하는 조건문을 추가(catch 블록의 코드를 조건문에 옮기기)
2. catch 문에 어서션을 추가하고 테스트
3. try 문과 catch 문을 제거
4. 테스트

### 예시

https://github.com/young0264/refactoring-2nd-edition/commit/dd75ef8a125684db6ba2e20caca7a61cff009c3e