## 조건부 로직 간소화

- 프로그램을 복잡하게 만드는 주 요인 → 조건문
- 조건문 리팩터링
    - 복잡한 조건문 → 조건문 분해하기(10.1)
    - 논리적 조합을 명확하게 다듬기 → 중복 조건식 통합하기(10.2)
    - 함수의 핵심 로직에 들어가기전 검사 → 중첩 조건문을 보호 구문으로 바꾸기(10.3)
    - switch 문이나 똑같은 분기문이 등장한다면 → 조건문 로직을 다형성으로 바꾸기(10.4)
    - Null과 같이 특이 케이스 처리 → 특이 케이스 추가하기(10.5)
    - 프로그램의 상태를 확인, 결과에 따라 다르게 동작해야 하는 상황
      → Assertion 추가하기(10.6)
    - 제어 플래그를 이용해 코드 동작 흐름을 변경하는 코드 → 제어 플래그를 탈출문으로 바꾸기(10.7)

## 10.1 조건문 분해하기

### 배경

- 다양한 조건, 다양한 코드 →긴 함수 탄생 → 어려움 증가 → 긴함수는 목적이 제대로 드러나지가 않음 → 거대한 코드 블록, 부위별로 분해, 각 덩어리에 의도가 드러나도록 함수를 바꿔주자. → 전체적인 의도가 더 확실히 드러남
- 조건식과 각 조건절에 조건문 분해하기

  → 즉, **복잡한 조건식을 의도가 드러나는 코드로 바꿔주는 작업**


### 절차

- 조건식과 그 조건식에 딸린 조건절 각각을 함수로 추출함(6.1)

### 예시

---

## 10.2 조건식 통합하기

### 배경

- 조건에 따라 수행하는 동작이 똑같은 동작 로직이 같은 조건식은 하나로 통합하는게 나음
- 통합하는 과정에서 코드 의도를 더욱 명확하게 살릴 수 있음.

  복잡한 조건식을 함수로 추출하면 코드 의도가 더욱 분명해지는 경우가 많음

- 하지만 독립된 로직이면 이 기법을 사용하지 않는게 나음.

### 절차

1. 조건식들에 부수효과 확인
2. 조건문 두 개 선택 후, 조건식들을 논리 연산자로 결합함
3. 테스트
4. 조건이 하나만 남을 때까지 반복
5. 하나로 합쳐진 조건식을 함수로 추출할지 고려

### 예시

```bash
1. refactor
2. c2f8621c
```

---

## 10.3 중첩 조건문을 보호 구문으로 바꾸기

### 배경

- **조건문이 사용되는 케이스**는 흔히 두개.
    - 참인 경로와 거짓인 경로 모두 정상적인 로직이 필요한 경우(if/else 사용)
    - 참과 거짓 경로 중 한쪽만 정상적인 로직이 필요한 경우.

      비정상 조건을 if에서 검사 후 조건이 참이면(비정상이면) 함수에서 빠져나옴 (**보호구문, guard clause == 비정상 조건을 if절에서 검사**)

- 리팩터링의 핵심은 의도를 부각하는 데에 있음.
- ‘보호구문’은 “이건 이 함수의 핵심이 아니다. 이 일이 일어나면 무언가 조치를 취한 후 함수에서 빠져나온다.” 라고 말한다함
- 정상적인 로직이

### 절차

1. 교체해야 할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 바꿈
2. 테스트
3. 1-2 를 반복함
4. 모든 보호 구문이 같은 결과를 반환한다면, 보호 구문들의 조건식을 통합함.

### 예시

```bash
a9f97791
4b57ae2b
740f1c19
```

---

## 10.4 조건부 로직을 다형성으로 바꾸기

### 배경

- 조건부 로직은 해석하기 난해, 직관적으로 구조화 할 방법을 항상 고민해야함
- 클래스와 다형성을 이용하면 확실하게 분리가 가능함
- 타입을 여러 개 만들고 각 타입이 조건부 로직을 자신만의 방식으로 처리하도록 구성하는 방법

### 절차

1. 다형성 동작을 표현하는 클래스들이 없다면 생성, 팩터리 함수도 같이 만들자
2. 호출하는 코드에서 팩터리 함수를 사용하도록 함
3. 조건부 로직 함수를 슈퍼 클래스로 옮김
4. 서브 클래스 중 하나를 선택함. 슈퍼 클래스에 조건부 로직 메서드를 오버라이딩함. 조건부 문장 중 선택된 서브클래스에 해당하는 조건절을 서브클래스 메서드로 복사한 후 적절히 수행
5. 같은 방식으로 각 조건절을 해당 서브클래스에서 메서드로 구현
6. 슈퍼클래스 메서드에는 기본 동작 부분만 남김

### 예시

---

## 10.5 특이 케이스 추가하기

### 배경

데이터 구조의 특정 값을 확인한 후 똑같은 동작을 반복하는 코드가 곳곳에 등장?!

- 이 같은 경우는 반복되는 코드들을 한 곳으로 모아야 효율적임
- 특수한 경우의 공통 동작을 하나에 모아서 사용하는 경우가 특이 케이스 패턴(Special Case Pattern)
- 여러 형태로 표현 가능. 값 객체로 표현하는 것도 가능, 어떠한 동작을 수행할 수도 있음.
- 주로 사용되는 경우가 null인 경우라서 Null Object Pattern 이라고도 하고, null 외에도 특이 케이스 패턴을 적용할 수 있음.

### 절차

리팩토링에서는 데이터 구조(클래스)가 있다고 가정. → 이를 컨테이너라 부르겠음.

- 해당 속성이 특이한 값인지를 검사하고 우리는 이 대상이 가질 수 있는 값 중 특별하게 다뤄야 할 값을 특이케이스 클래스로 대체하겠음
1. 컨테이너에 특이 케이스인지 검사하는 속성을 추가하고 false를 반환함
2. 특이 케이스 객체를 만듦. 특이 케이스 인지를 검사하는 속성만 포함하고 이 속성은 true를 반환함
3. 클라이언트에서 특이 케이스인지를 검사하는 코드를 함수로 추출. 모든 클라이언트가 값을 직접 비교하는 대신 방금 추출한 함수를 사용하도록 고침
4. 코드에 새로운 특이 케이스 대상을 추가함. 함수의 반환값으로 받거나 변환 함수를 적용
5. 특이 케이스를 검사하는 함수 본문을 수정하여 특이 케이스 객체의 속성을 사용
6. 테스트
7. 여러 함수를 클래스로 묶기(6.9)나 여러 함수를 변환 함수로 묶기(6.10)을 적용하여 특이 케이스를 처리하는 공통 동작을 새로운 요소로 옮김
8. 아직도 특이 케이스 검사 함수를 이용하는 곳이 남아있다면 검사 함수를 인라인(6.2)

---

## 10.6 어서션 추가하기(`얘기하기 좋음`)

`그리고, 로직상 할인 금액이 음수 가능함.`

### 배경

- 특정한 조건 내에서만 동작하는 코드.

  ex) 제곱근 계산은 입력이 양수일때만 동작

  객체로 접근하면 필드로 동작을 할 수도 있음

    - 이런 조건들이 명시적으로 드러나면 좋겠지만 그렇지 않은 경우도 있음.

      알고리즘을 보고 연역적으로 알아내야 하는 경우도 있음.

    - 주석도 좋지만, assertion을 이용해 코드 자체에 삽입해 놓는것이 가장 좋음
    - Assertion은 항상 참이라고 가정하는 조건부, 이게 참이 아닌 값이 넘어온다면 프로그래머가 실수했다라는 뜻.
    - Assertion의 실패는 프로그램 기능 동작에 아무 이상이 없어야함. (단지 검사로만 이용)
    - Assertion 의 본질적인 목적은 프로그램이 어떠한 상태여야 하는지 다른 개발자들에게 설명해주는 도구라는 점
    - 디버깅의 장점, 소통 수단으로서의 가치, 버그를 잡고서도 Assertion을 코드에 남겨둠
    - 테스트 코드가 있다면 Assertion의 디버깅 용도는 줄어듬

### 절차

- 참이라는 가정이 보이면 그 조건을 명시하는 assertion을 추가함

### 예시
```bash
13a10091
```

---

## 10.7 제어 플래그를 탈출문으로 바꾸기

`제어 플래그를 return으로 바꾸어 해결한다는 생각은 어디서 나온걸까?`

### 배경

- 제어 플래그? : 코드의 동작을 바꾸는 곳에서 나옴.
- 조건절에서는 제어 플래그를 통해 검사하고 어떤 문에서는 계산을 통해 제어 플래그의 값을 바꾸는 구조로 되어있음.
- 제어 플래그를 사용하면 코드를 이해하기 어려워짐.
- 제어 플래그의 주 서식지는 반복문.
- break문이나 continue 문에 익숙하지 않은 사람이거나, 함수의 return을 적절하게 이용하지 못하면 나옴.

### 절차

1. 제어 플래그를 사용하는 코드를 함수로 추출할지 고려
2. 제어 플래그를 갱신하는 코드 각각을 적절한 제어문으로 바꿈
3. 바꿀 때마다 테스트 진행
4. 모두 수정했다면 제어 플래그를 제거함.

### 예시

- 악당(miscreant) 찾기 예시

    ```bash
    1. bb6bc5a3
    2. 8ddd4979
    3. 57ae8761
    4. 9f5a91f2
    ```

- Optional 리팩터링 장점


    | 가독성 | 코드가 무엇을 하는지 더 명확하게 읽힘 |
    | --- | --- |
    | 선언형 프로그래밍 스타일 | "어떻게"보다 "무엇을"에 집중 |
    | 사이드 이펙트 제거 | 불변/함수형 스타일에 가까움 |
    | 확장성 | 조건 추가, 병렬 처리, 외부 컬렉션 매핑 등에 유리 |
    | null-safe | Optional 체이닝으로 안정성 확보 가능 |