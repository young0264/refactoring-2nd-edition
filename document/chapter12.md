## 상속 다루기

- 오용하기 쉬운 상속
- 상속은 막강한 도구지만 잘못된 곳에서 사용되면 문제가 생길 수 있음.

  이런경우 서브클래스를 위임으로 바꾸기(12.10), 슈퍼 클래스를 위임으로 바꾸기(12.11)적용 가능


---

## 12.1 메서드 올리기

### 배경

중복 코드 제거는 중요함. 중복을 놓치는 문제가 생기기 쉬움

메서드 올리기를 적용하는 가장 쉬운 예는 메서드들의 본문 코드가 똑같을 경우임

- 이럴땐 슈퍼클래스에 복붙 → 테스트로 검증(얼마나 테스트를 잘 만들어 놓았는가에 의존)
- 서로 다른 두 클래스의 두 메서드를 매개변수화하면 궁극적으로 같은 메서드가 됨 (함수를 매개변수화 하기 _ 11.2)
- 해당 메서드에서 참조하는 필드들이 서브 클래스에만 있는 경우는 메서드 올리기를 적용하기 힘들 수 있음
- 전체 흐름은 비슷하지만 세부 내용이 다르다면 **템플릿 메서드 만들기 디자인 패턴**을 고려

### 절차

1. 똑같이 동작하는 메서드인지 살펴보기
2. 옮길 메서드에서 다른 메서드를 호출하거나, 필드를 참조하는데 이게 슈퍼클래스에서도 가능한지 확인
3. 메서드 시그니처가 다르다면 **함수 선언 바꾸기**(6.5절)로 슈퍼 클래스에서 사용하고 싶은 형태로 통일
4. 슈퍼 클래스에서 메서드를 생성하고, 대상 메서드의 코드를 복붙
5. 정적 검사 수행
6. 서브 클래스 중 하나의 메서드를 제거
7. 테스트
8. 모든 서브 클래스의 메서드가 없어질 때까지 다른 서브 클래스이 메서드를 하나씩 제거

### 예시

---

## 12.2 필드 올리기

### 배경

- 서브 클래스들이 서로 다른 시간대(독립적으로)에 개발되었거나 뒤늦게 하나의 계층 구조로 통합되는 경우 필드 중복이 발생할 수 있음
- 분석 후, 분석 결과가 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼 클래스로 올리자.
- 이렇게 하면 데이터 선언 중복을 제거하는게 가능해짐. 슈퍼 클래스로 옮겨서 중복을 제거할 수 있음

### 절차

1. 후보 필드들 모두가 같은 방식으로 사용하는지 분석하기
2. 분석이 끝나야 리팩터링 시작할 수 있음.
3. 슈퍼 클래스에 새로운 필드를 생성
4. 서브 클래스들의 필드를 제거
5. 테스트

### 예시

---

## 12.3 생성자 본문 올리기 `역전`

`얘기거리`

`재정의 된 자식 메서드 호출`

`→ 개인적으로는 좀 불편한 구조라고 생각되는데 어떻게 해야 이해하기 쉬울까?(트래킹이 힘들다)`

### 배경

생성자는 일반 메서드와 많이 달라서 생성자가 하는일에 제약을 둠

호출 순서에 제약이 있기 때문

### 절차

1. 슈퍼 클래스에 생성자가 없다면 하나 정의함. 서브 클래스들의 생성자들에서 슈퍼 클래스의 생성자를 호출하는지 확인함
2. **문장 슬라이드(8.6)**을 이용해 공통 문장 모두를 super 호출 직후로 옮김
3. 공통 코드를 슈퍼 클래스에 추가하고 서브 클래스들에게서 제거. 공통으로 참고하는 값들은 super로 건넴
4. 테스트
5. 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 **함수 추출하기(6.1)**과 **메서드 올리기(12.1)**을 차례로 적용

→ 즉, 상위에서 호출하는 것으로 통합(메서드를 하위에서 재정의 했다면, 하위 메서드 호출)

### 예시

```java
package young.refactoring.ch12.pullUpConstrucBody;

public class Manager extends Employee {
    Grade grade;

    public Manager(String name, Grade grade, boolean isPrivileged) {
        super(name);
        this.grade = grade;

        // finishConstruction는 부모 메서드 호출.
        //  -> 메서드 내 isPrivileged()는 재정의 된 자식 메서드 호출
        // 개인적으로는 좀 불편한 구조라고 생각되는데 어떻게 해야 이해하기 쉬울까?(트래킹이 힘들다)
        finishConstruction();
    }

    @Override
    public boolean isPrivileged() {
        return grade.val > 4;
    }
}

```

---

## 12.4 메서드 내리기

### 배경

특정 서브 클래스 하나와만 관련된 메서드는 슈퍼 클래스에서 제거하고 서브 클래스에 두는 것이 더 깔끔하다 (`LSP원칙`: 부모 클래스의 행동 규약을 자식 클래스가 위반하면 안된다는 뜻)

- 슈퍼 클래스에서 제공하는 기능이 어떤 서브 클래스에서 사용하는지 명확할 때 사용해야함.

### 절차

1. 대상 메서드를 모든 서브 클래스에 복사
2. 슈퍼 클래스에서 그 메서드 제거
3. 테스트
4. 메서드를 사용하지 않는 서브클래스에선 제거
5. 테스트

### 예시

---

## 12.5 필드 내리기

### 배경

서브 클래스 하나 (혹은 소수)에서만 사용하는 필드는 해당 서브 클래스로 옮기기

### 절차

1. 대상 필드를 모든 서브클래스에서 정의
2. 슈퍼 클래스에서 해당 필드 제거
3. 테스트
4. 사용하지 않는 서브클래스에선 필드 제거
5. 테스트

### 예시

---

## 12.6 타입 코드를 서브클래스로 바꾸기

### 배경

소프트웨어 시스템에서는 비슷한 대상을 특정 특성에 따라 구분해야할 때가 있음

→ 직원 - 담당업무(엔지니어, 관리자, 영업자), 주문 시급성(급함, 보통)

- 타입 코드를 프로그래밍에서 자주 사용
- 특성에 따라서 다르게 동작하거나 다른 데이터가 필요할 때

  → 서브 클래스를 사용하여 해결 가능

- 서브 클래스를 이용할지 타입 코드를 이용할지 고민해볼 문제
    - 서브 클래스: 하위 타입인 클래스를 생성하는 방식
    - 타입 코드: 속성을 클래스로 만들고 속성을 서브클래스로 정의하는 방식

### 절차

1. 타입 코드 필드 캡슐화(자가 캡슐화)
2. 타입코드 선택 후 그 값에 해당하는 서브 클래스 생성
3. 매개변수로 받은 타입 코드와 방금 만든 서브 클래스를 매핑하는 선택 로직 생성
4. 테스트
5. 타입 코드 값 각각에 서브 클래스 생성과 선택 로직 추가를 반복. 하나씩 완성때마다 테스트
6. 타입 코드 필드 제거
7. 테스트
8. 타입 코드 접근자를 이용하는 모든 메서드에 **메서드 내리기(12.4)**와 **조건부 로직을 다형성으로 바꾸기(10.4)**를 이용

### 예시

```java
//EmployeeType은 직접 인스턴스화되면 안 되고,
// 반드시 Manager, Engineer, Salesperson 같은 서브클래스가 사용되길 의도

public abstract class EmployeeType {
    private final String value;

    protected EmployeeType(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }
}

public class Engineer extends EmployeeType {

    public Engineer() {
        super("engineer");
    }
}
```

---

## 12.7 서브클래스 제거하기

→ `상속의 강결합 고려하여 실습해보기`

### 배경

서브 클래스는 원래 데이터 구조와는 다른 변종을 만들어서 동작을 달라지게 하는 유용한 수단

소프트웨어가 커지면서 다른 모듈로 이동하거나 사라지기도 하면서 한번도 활용되지 않기도 함

더 이상 쓰이지 않는 서브 클래스는 그냥 슈퍼 클래스가 대체하는게 최선

### 절차

1. 서브 클래스의 생성자를 팩토리 함수로 생성
2. 서브 클래스의 타입을 검사하는 코드가 있다면 그 검사 코드를 함수 추출과 함수 옮기기를 통해서 슈퍼 클래스로 옮김
3. 서브 클래스의 타입을 나타내는 필드를 슈퍼 클래스에 만듦
4. 서브 클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하도록 수정
5. 서브 클래스를 지움
6. 테스트

### 예시

---

## 12.8 슈퍼클래스 추출하기(부모 클래스 만들기)

### 배경

비슷한 일을 수행하는 두 클래스가 있으면 공통 부분을 슈퍼 클래스에 넣을 수 있음

### 절차

1. 빈 슈퍼 클래스를 만듦. 원래의 클래스들이 새 클래스를 상속받도록 함
2. 테스트
3. 메서드 올리기(12.1), 필드 올리기(12.2), 생성자 본문 올리기(12.3)를 적용하여 공통 요소를 슈퍼 클래스로 옮기기
4. 서브 클래스에 남은 메서드들을 검토. 공통되는 부분이 있다면 함수로 추출해서 메서드에 올리기(12.1)을 적용
5. 원래 클래스들을 사용하는 코드를 검토하여 슈퍼 클래스의 인터페이스를 사용하게 할지 고민해보기

### 예시

---

## 12.9 계층 합치기

### 배경

구조를 리팩터링 하다보면 기능을 올리거나 내리거나 하는 일이 많음

클래스는 부모와 너무 비슷해져서 독립적으로 존재해야 할 이유가 사라지기도 함

이때가 합쳐야 할 시점

### 절차

1. 두 클래스 중 제거할 클래스를 고름
2. 필드 올리기/내리기, 메서드 올리기/내리기를 적용해서 하나의 클래스로 만듦
3. 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 바꿈
4. 빈 클래스 제거
5. 테스트

### 예시

---

## 12.10 서브클래스를 위임으로 바꾸기

`상속의 강결합의 단점에 대한 리팩터링`, `이게 중요하다 생각`

### 배경

특성에 따라 동작이 달라지는 객체들은 상속으로 표현하는게 자연스러움 공통 데이터와 동작(메서드)는 모두 슈퍼 클래스에 두고 서브 클래스는 자신에 맞게 기능을 추가하거나 오버라이드 하면 됨.

하지만 단점이 있음

- 한 번만 쓸 수 있는 카드라는 점

  ex) 객체의 동작을 나이대와 소득 수준에 따라 달라지게 하고 싶다면 서브 클래스는 젊은이와 어르신이 되거나 혹은 부자와 서민이 되어야함. 둘 다는 안됨

- 상속은 클래스들의 관계를 아주 긴밀하게 협업함(강결합 이란 말)
- 부모를 바꾸면 자식들의 기능을 해치기가 쉽기 때문에 주의(부모 변경시.!)
- 자식들이 슈퍼 클래스를 어덯게 상속해 사용하는지 이해해야함
- 부모와 자식이 서로 다른 모듈에 속하거나 다른 팀에서 구현한다면 문제는 더욱 커짐
- 위임(Delegate)는 위의 두 문제를 모두 해결해줌
    - 다양한 클래스에서 서로 다른 이유로 위임할 수 있음
    - 위임은 상속보다 결합도가 낮다

“상속보다는 컴포지션을 사용하라” → 여기서 말하는 컴포지션 == 위임

- 그렇지만 저자는 상속을 자주 사용함
    - 왜냐? → 이런 배경에는 **나중에라도 필요하면 언제든 서브 클래스를 위임으로 바꿀 수 있기 때문**
- 처음에 상속으로 접근한 다음, 문제가 생기면 위임으로 갈아탐
- 이 원칙을 주장한 디자인 패턴책은 상속과 컴포지션을 함께 사용하는 방법을 설명해줌

  (상속의 과용을 설명)

- 이 패턴을 State Pattern 이나 Strategy Patter이라고 생각해도 좋음

  구조적으로 두 패턴은 위임 방식으로 계층 구조를 분리해줌


### 절차

1. 생성자를 호출하는 곳이 많다면 생성자를 팩터리 함수로 바꿈(11.8)
2. 위임으로 활용할 빈 클래스를 만듦. 이 클래스의 생성자는 서브 클래스에 특화된 데이터를 전부 받아야하며 보통은 슈퍼 클래스를 가리키는 역참조(Back Reference)도 필요함
3. 위임을 저장할 필드를 슈퍼 클래스에 추가함
4. 서브 클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고 위임 필드에 대입해 초기화함
5. 서브 클래스 메서드 중 위임 클래스로 이동할 것을 고름
6. 함수 옮기기(8.1)을 적용해 위임 클래스로 옮김. 원래 메서드에서 위임하는 코드는 지우지 않음
7. 서브 클래스 외부에도 원래 메서드를 호출하는 코드가 있다면 서브 클래스의 위임 코드를 슈퍼 클래스로 옮김. 이때 위임이 존재하는지를 검사하는 보호 코드로 감싸야함. 호출하는 외부 코드가 없다면 원래 메서드는 죽은 코드가 되므로 제거함
8. 테스트
9. 서브 클래스의 모든 메서드가 옮겨질 때까지 과정을 반복함
10. 서브 클래스의 생성자를 호출하는 코드를 찾아서 슈퍼 클래스의 생성자를 사용하도록 수정함
11. 테스트
12. 서브 클래스를 삭제함

### 예시

---

## 12.11 슈퍼클래스를 위임으로 바꾸기

### 배경

객체 지향 프로그래밍에서 상속은 기존 기능을 재활용하는 강력한 수단임. 기존 클래스를 상속해 입맛에 맞게 오버라이드하거나 새 기능을 추가하면 됨.

하지만 상속이 혼란과 복잡도를 키우는 방식으로 이뤄지기도 함

**자바의 스택 클래스**가 그 예

- 자바의 스택은 리스트를 상속하고 있는데 데이터를 저장하고 조회하는 리스트의 기능을 재활용하겠다는 생각이 초래한 결과
- 재활용 관점에서는 좋음. 하지만 상속에는 문제가 있음.
- 리스트 연산 중 스택에는 적용되지 않는게 많은데도 그 모든 연산이 스택 인터페이스에 노출되어있음.
- 자바의 스택이 슈퍼클래스를 위임으로 바꾸는 이번 리팩터링을 적용할 좋은 예임.
- 슈퍼 클래스의 기능들이 서브 클래스에 어울리지 않는다면 그 기능들을 상속을 통해 이용하면 안된다는 신호임.
- 제대로 된 상속이라면 서브 클래스가 슈퍼 클래스의 모든 기능을 사용해야하고, 서브 클래스의 인스턴스를 슈퍼 클래스의 인스턴스로도 취급할 수 있어야함
- 이 외에도 서브 클래스 방식 모델링이 합리적일 때도 슈퍼 클래스를 위임으로 바꾸기도 함
    - 슈퍼/서브 클래스가 아주 강하게 결합되어 있어서 슈퍼 클래스를 수정하면 서브클래스가 망가지기 쉽기 때문.
    - 위임의 기능을 이용할 호스트의 함수 모두를 전달함수로 만들어야함. 지루하더라도 문제가 생길 가능성은 적어짐
- 의미상 적합한 조건이라면 상속은 간단하고 효과적인 매커니즘임.
- 상속이 최선이 아니게되면 언제든 리팩터링을 이용해 슈퍼 클래스를 위임으로 바꾸면 됨.

→ 상속을 먼저 적용하고 나중에 문제가 생기면 슈퍼 클래스를 위임으로 바꾸라는 것이 최종 조언

### 절차

1. 슈퍼 클래스 객체를 참조하는 필드를 서브 클래스에 만듦.(이번 리팩터링이 끝나면 **슈퍼 클래스**가 **위임 객체**가 될 것이므로 **위임 참조**라고 부르겠음). 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화함
2. 슈퍼 클래스의 동작 각각에 대응하는 전달 함수를 서브 클래스에 만듦. 물론 **위임 참조**로 전달함. 서로 관련된 함수끼리 그룹을 묶어서, 그룹을 하나식 만들때마다 테스트함.
3. 슈퍼 클래스의 동작 모두가 전달 함수로 오버라이드 되었다면 상속 관계를 끊음

### 예시