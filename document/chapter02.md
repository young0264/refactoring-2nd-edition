
## 02 리팩터링 원칙

리팩터링 전반에 적용되는 원칙 몇 가지를 이야기하는 시간 갖기

---

### 2.1 리팩터링 정의

___

‘리팩터링(refactoring)’ 이란 용어는 명사와 동사로 쓸 수 있다.

**리팩터링**:[명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

- **앞장의 함수 추출하기**, **조건부 로직을 다형성으로 바꾸기** 처럼 이름 붙은 리팩터링 기법들이 이 정의에 해당함

**리팩터링(하다)**: [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

- ex) 두 버전의 용어를 한 문장에 담으면 ‘앞으로 몇 시간은 리팩터링할 것 같은데 그 사이 적용하는 리팩터링은 수십가지나 될 것 같다’ 로 표현
- 코드를 정리하는 모든 작업이 ‘리팩터링’이 아닌, 앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링
- 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일(작은 하나이거나 작은 작업 여러개가 합쳐진 모습일 수 있음)

  따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않더라도 언제든 멈출 수 있음

  → “리팩터링하다가 코드가 깨져서 며칠이나 고생했다” 는 리팩터링이 아님


코드베이스를 정리하거나 구조를 바꾸는 작업은 ‘재구성(restructuring)’이라는 포괄적인 용어로 표현하고 리팩터링(refactoring)이라고 표현하고, 리팩터링은 재구성 중 특수한 한 형태로 봄. 한번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습이 비효율적으로 보일 수 있지만, 오히려 작업을 더 빨리 처리할 수 있음. 단계들이 체계적으로 구성되며, 디버깅하는데에 시간을 빼앗기지 않기 때문

**겉보기 동작(observable behavior)** : 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다는 뜻

- **함수 추출하기** → 콜스택이 달라져서 성능이 바뀔 수 있다. 하지만 사용자 관점에서는 달라지는 점이 없어야함
- **함수 선언 바꾸기, 함수 옮기기** → 모듈의 인터페이스가 바뀔 때가 많음. 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아있어야 함.(수정은 필요하겠지만)

리팩터링은 성능 최적화와 비슷

- 코드를 변경하지만 전반적인 기능은 그대로 유지. 단지 목적이 다름.
- 목적
    - [리팩터링] : 코드를 이해하고 수정하기 쉽게 만드는 것. 성능은 좋아질 수도 나빠질 수도 있음.
    - [성능 최적화] : 속도 개선에만 신경씀

---

### 2.2 두개의 모자

___

소프트웨어를 개발할 때 목적이 ‘기능 추가’냐 아니면 ‘리팩터링’이냐를 명확하게 구분하여 작업함. 켄트벡은 이를 두개의 모자(tow hats)에 비유했음

[기능 추가 모자]

- 기존 코드는 절대 건드리지 않고 새 기능을 추가함
- 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정함

[리팩터링 모자]

- 기능 추가는 절대 하지 않음.
- 오로지 코드 재구성에만 전념
- 테스트도 새로 만들지 않음. 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정함.

**기능 추가 ↔ 리팩터링**

소프트웨어를 개발할 때 두 모자를 자주 바꿔써야함(습관)

항상 본인이 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야함

---

### 2.3 리팩터링하는 이유

___

리팩터링은 만병통치약이 아님. 코드를 건강한 상태로 유지시켜주는 약. 정도

**리팩터링하면 소프트웨어 설계가 좋아짐**

- 리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 썩기 쉬움
    - 아키텍처를 이해하지 못한채 단기 목표만을 위한 코드 수정은 기반 구조가 무너지기 쉬움
    - 코드만 봐서 설계 파악 힘듦
    - 코드 구조가 무너져 설계를 유지하기가 어렵고 부패되는 속도는 빨라짐.
    - 코드가 길수록 실수없이 수정하기가 어려워짐,
    - 이해해야할 코드량도 늘어남
- 반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것
    - 중복 코드 제거 → 언제나 고유한 일을 수행함을 보장할 수 있음.
    - 코드량이 준다고 속도가 빨라지진 않지만 수정하는데 드는 노력은 달라짐.
    

**리팩터링하면 소프트웨어를 이해하기 쉬워짐**

- 프로그래밍은 여러 면에서 마치 컴퓨터와 대화하는 것과 같음.
    
    컴퓨터에게 시킬 일을 표현하는 코드를 작성하면, 컴퓨터는 정확하게 시킨대로 반응함
    
    그래서 이를 표현한 코드의 차이를 최대한으로 줄여야함
    
- 몇달 후 누군가 내 코드를 수정하고자 할 때, 잘 읽히게끔 개발하는게 중요
- 프로그램을 동작시키는 데만 신경쓰다보면 나중에 그 코드를 다룰 개발자를 배려하지 못함.
- 리팩터링은 코드가 더 잘 읽히게 도와줌. → 코드의 목적이 더 잘 드러나게, 명확하게 전달하기 위해
- 나 자신을 위해(기억하지 않기 위해) 기억할 필요가 있는 것들은 의도적으로 최대한 코드에 담기.

**리팩터링하면 버그를 쉽게 찾을 수 있음**

- 코드를 이해하기 쉽다 == 버그를 찾기 쉽다
- 뛰어난 습관을 가진 프로그래머가 되도록 노력

**리팩터링하면 프로그래밍 속도를 높일 수 있음**

- 리팩터링하면 개발 속도를 높일 수 있음
- 내부 품질이 뛰어난 코드베이스 작성의 필요성
    - 코드가 명확하면 버그를 만들 가능성도 줄음
    - 버그를 만들더라도 디버깅이 쉬움.
    
    → ‘지구력 가설(Design Stamina Hypothesis) : 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있음
    

---

### 2.4 언제 리팩터링해야 할까?

___

한시간 간격으로 리팩터링을 수행함

```
돈 로버츠(Don Roberts)
1. 처음에는 그냥 한다
2. 비슷한 일을 두번째로 하게되면(중복에 당황스러워도), 일단 계속 진행한다
3. 비슷한 일을 세번째 하게되면 리팩터링한다.
(삼진 리팩터링)
```

**준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**

- 코드베이스에 기능을 새로 추가하기 직전
- 구조를 살짝 바꾸면 다른 작업을 하기 훨씬 쉬워질만한 부분 찾기
- 복붙으로 문제를 해결할 수 있지만 중복코드를 생성하는 단점.
    
    → 복제한 코드가 어디에있는지 일일이 찾아내서 수정해야함
    
    → 함수 매개변수화하기를 적용함
    

**이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**

- 코드를 수정하려면 먼저 코드를 파악해야함
- 리팩터링시 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지를 찾아봄.(조건부로직, 함수의 이름 등)
- 내가 머리로 이해한것을 코드에 옮겨담기. 기억하기 쉽게 리팩토링하기.
- 코드를 분석할 때 리팩터링하면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 됨.
    
    → 코드 아래에 숨어있는 다양한 기회 발견
    

**쓰레기 줍기 리팩터링**

- 간단히 수정할 수 있는 것은 즉시 고치기, 시간이 좀 걸리는 일은 짧은 메모만 남기고 하던일을 하고 처리.
- 캠핑규칙
    - 조금씩 개선
    - 작업을 잘게 나누면 몇달에 걸쳐 진행하더라도 그 사이 한 순간도 코드가 깨지지 않음.

**계획된 리팩터링과 수시로 하는 리팩터링**

- 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링을 함께 수행함
    
    → 프로그래밍 과정에 자연스럽게 녹인 것. (중요)
    
    → 마치 if문 작성 시간을 따로 구분하지 않는 것과 같다.
    

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(만만치 않을 수 있음) 그리고 쉽게 수정하자
_ 켄트 벡
> 
- 리팩터링의 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야함
- 버전 관리 시스템에서 리팩터링 커밋과 추가 커밋을 분리해야 한다는 조언.
    - 리팩터링과 기능 추가는 밀접하게 연관되어 있음.
        
        → 굳이 나누는 것은 시간낭비일 수 있다는 생각.
        
    - 리팩터링 커밋을 분리한다고해서 무조건 좋은 것은 아님을 명시하고, 팀에 적합한 방식을 실험을 통해 찾는 노력이 필요함.

**오래 걸리는 리팩터링**

- 대부분의 리팩터링은 몇분 내로 끝남. 길어야 몇시간.
- 하지만 대규모 리팩터링(라이브러리 교체, 컴포넌트 빼는작업, 의존성 정리 작업 등등)
    - 그렇다 하더라도 팀 전체가 리팩터링에 매달리는 데는 회의적
    - 예컨대 라이브러리를 교체할 때는 기존것과 새 것 모두를 포용하는 추상 인터페이스부터 마련.
        
        그리고 이 추상 인터페이스를 호출하도록 만들고나면 라이브러리를 훨씬 쉽게 교체할 수 있음
        
        (추상화로 갈아타기 전략., Branch By Abstraction)
        

**코드 리뷰에 리팩터링 활용하기**

- 코드리뷰는 개발팀 전체에 지식을 전파하기 좋음
    
    경험이 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있음
    
    깔끔한 코드를 작성하는데 도움이 될 수 있고 다른 사람의 아이디어를 얻을 수 있는 장점도 있음.
    
    기회가 닿는 대로 코드리뷰를 하는게 좋음
    
- 리팩터링을 활용하기 전에는 코드를 읽고 이해후 몇가지 개선 사항을 제시했다면 지금은 새로운 아이디어가 떠오르면 리팩터링을 해봄
    
    이 과정을 몇 번 반복하다보면 내가 떠올린 아이디어의 실제 적용했을 때의 모습을 명확하게 볼 수 있음. 
    
    그렇지 않았다면 떠올릴 수 없는 한차원 높은 아이디어가 떠오르기도 함
    
    → 그러므로 리팩터링은 결과를 더 구체적으로 도출하는데 도움을 줌
    
- 개선안들을 제시하는데서 그치지 않고, 그 중 상당수를 즉시 구현해볼 수 있기 때문
- 코드 리뷰를 이런 식으로 한다면 훨씬 더 큰 성취감을 얻을 수 있음

---

**관리자에게는 뭐라고 말해야 할까?**

“관리자에게 리팩터링에 대해 어떻게 말해야 할까?”

관리자와 고객은 ‘리팩터링은 누적된 오류를 잡는 일이거나 혹은 가치 있는 기능을 만들어내지 못하는 작업’ 이라고 오해하여 리팩터링이 금기어가 돼버린 조직도 있음. 

- 리팩터링만을 위해 일정을 몇 주간 잡는 개발팀을 보면 이런 오해는 커짐.
- 관리자가 기술에 정통하고 설계 지구력도 잘 이해하고 있다면 리팩터링의 필요성을 쉽게 설득 가능
    
    → 정기적인 리팩터링 권장 및 팀이 리팩터링을 충분히 잘하고 있는지 살펴보기도 함.
    
- 소프트웨어 개발자는 프로다.
- 프로개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다.

---

**리팩터링하지 말아야 할 때**

지금까지 이야기를 정리하면 무조건 리팩터링을 권장한다고 들릴 수 있다. 하지만 리팩터링을 하면 안되는 상황도 있다.

- 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 안한다.
- 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.
- **내부 동작을 이해해야 할 시점에 리팩터링을해야 효과를 제대로 볼 수가 있기 때문이다.**
- 리팩터링하는 것보다 처음부터 새로 작성하는게 쉬울때도 리팩터링을 하지 않는다.
- 리팩터링은 직접 해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을 때도 많음. 뛰어난 판단력과 경험이 뒷받침 되어야함.

---

### 2.5 리팩터링 시 고려할 문제

**새 기능 개발 속도 저하**

- 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것
- 새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이면 주저하지 않고 리팩터링을 함
- 내가 직접 건드릴 일이 없거나 불편한 정도가 심하지 않는다고 판단되면 리팩터링을 하지 않음
- 리팩터링의 본질은 ‘클린코드’나 ‘바람직한 엔지니어링 습관’에 있지 않다.
- 리팩터링의 오로지 경제적인 이유로 하는 것.
    
    기능 추가 시간을 줄이고, 버그 수정 시간을 줄여줌. 
    
    이를 인식하는데 그치지 말고 다른 사람과 대화할 때도 이 점을 명심해야 함.
    

**코드 소유권**

- 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많음.
- 함수 이름을 바꾸고 싶어서 호출부를 바꿀 수 있지만 소유자가 다른팀이라 이를 바꿀 권한이 없을 수 있음
    
    or 바꾸려는 함수가 고객에게 제공해주는 API라면 쓰는 사람 모두를 알기 어려움
    
    or 코드 소유권이 나눠져있다면 리팩토링 하기 어려움
    
- 함수 이름을 바꾸고 싶다면 함수 바꾸기를 적용하고, 기존 함수는 새 함수를 호출하도록 만들면 됨
- 인터페이스는 복잡해지지만 클라이언트에 영향을 주지 않음.
- 이처럼 코두 소유권은 리팩터링에 영향을 주기 때문에 코드 소유권을 작은 단위로 나누는 것에 반대.
- 코드 소유권을 팀에두면 그 팀에 속한 팀원이라면 누구나 수정 가능(선호)

**브랜치**

- 보통 각 브랜치에서 각각 작업하다가, 결과물이 어느정도 쌓이면 마스터 브랜치에 통합해서 팀원과 공유하는 방식 사용.
    
    이러면 기능 전체를 한 브랜치에만 구현해놓고, 프로덕션 버전으로 릴리스할 때가 되어서야 마스터에 통합하는 경우가 많음. 이 방식을 선호하는 이들은 작업이 끝나지 않은 코드가 마스터에 섞이지 않고, 기능이 추가될 때마다 버전을 명확히 나눌 수 있고, 기능에 문제가 생기면 이전 상태로 쉽게 되돌릴 수 있어서 좋다고 한다.
    
- 하지만 단점이 있음.
    - 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워짐.
    - 마스터를 개인 브랜치로 수시로 리베이스(rebase)하거나 머지(merge)함
        
        하지만 여러 기능 브랜치에서 동시에 기능 개발이 진행되는 경우 해결 불가능.
        
    - ‘머지’와 ‘통합’은 다른 것
        - 머지(merge)는 단방향 → 브랜치만 바뀌고 마스터는 그대로임.
        - 통합(integratioin)은 마스터를 개인 브랜치로 가져와서(pull) 작업한 결과를 다시 마스터에 올리는 양방향 처리 → 마스터와 브랜치가 모두 변경됨
- 브랜치들이 독립적으로 개발되는 기간이 길어질수록 문제는 기하급수적으로 늘어남
- 브랜치 통합 주기를 2-3일 단위로 짧게 관리해야한다?
→ 더 짧게 관리해야 한다고 주장
- 지속적 통합 CI, 또는 트렁크 기반 개발_TBD_(Trunk-Based-Development)이라고 함.
- CI에 따르면 모든 팀원이 하루에 최소 한번은 마스터와 통합해야한다
    
    이러면 다른 브랜치들과 차이가 크게 벌어지지 않아 머지의 복잡도를 상당부분 찾출 수 있다.
    
- 하지만 CI를 적용하기위해 치러야 할 대가가 있다
    - 거대한 기능을 잘게 쪼개는 법을 배우고
    - 각 기능을 끌 수 있는 기능 토글을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록
- 머지의 복잡도를 줄일 수 있어 CI를 선호, but 가장 큰 이유는 리팩터링과 궁합이 좋음.
- 리팩터링은 코드 전반에 걸쳐 자잘하게 수정해야할 부분들이 있음.
    - 프로그램 전체에서 사용하는 함수 이름 바꾸기. → 머지 충돌이 발생하기 쉬움
- CI + Refactoring = extreme Programming(XP) , 켄트백
- 기능별 브랜치를 많이 사용해도, 마스터와 통합하는 작업을 매일/자주 해주기

**테스팅**

- 테스트 스위트(test suite)가 필요함
- 리팩터링을 위해서는 자가 테스트 코드(self-testing code) 마련이 필요함
- 새기능 추가 안전, 버그를 빠르게 발견 및 수정 가능, 버그 발생 위험 감소
- 견고한 테스트는 이런 불안감을 크게 해소할 수 있음. 갖춰두면 유용함.

**레거시 코드**

- 물려받은 레거시코드, 대체로 복잡하고 테스트도 갖춰지지 않은 것이 많음.
    
    그리고 다른 사람이 작성한 것.(지금상황. 끔찍)
    
- 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링 하기는 어려움.
- 테스트 보강.
    - 레거시 코드 활용 전략 _ 에이콘,2018)에 나온 지침을 충실히 따르기
        
        프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다는 것
        
- [캠핑 규칙]
    - 하나씩 공략
    - 조금이라도 개선하려고 노력
    - 처음 왔을 때보다 깨끗하게 치우기
    

**데이터베이스**

- 진화형 데이터베이스 설계(evolution database design), 데이터베이스 리팩터링
    - 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고
    - 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는데 있음
- 함수 선언 바꾸기에 따르면 데이터 구조의 원래 선언과 이 데이터 구조를 호출하는 코드를 모두 찾아서 한번에 변경해야함
- 예전필드 → 새필드 에 대한 모든 변경에 대한 부담이 따름
- 변환을 수행하는 코드를 작성한 후, 선언된 데이터 구조나 접근 루틴을 변경하는 코드와 함께 버전 관리 시스템에 저장함.
- 그런다음 데이터베이스를 다른 버전으로 이전할 때마다 현재 버전에서 원하는 버전 사이에 있는 모든 마이그레이션 스크립트를 실행함(?)
- 데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋아서 다른 리팩터링과는 결을 달리함.
    1. 새로운  필드 추가(사용하지 않음)
    2. 기존 필드와 새 필드를 동시에 업데이트 하도록 설정
    3. 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체
        
        이 과정에서 발생하는 버그도 해결, 클라이언트 교체 작업을 모두 끝내면 예전 필드 삭제.
        
    - 이렇게 데이터베이스를 변경하는 방식은 병렬 수정(parallel change 또는 팽창-수축)의 일반적인 예.

---

### 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

- 리팩터링은 탄탄한 테스트가 뒷받침되지 않으면 어려움
- 유연성 메커니즘(flexibility mechanism)을 소프트웨어이 심어줌.
    
    범용적으로 사용할 수 있겠다라는 생각에 함수에 매개변수들을 추가.
    
    - 당장의 쓰임에 비해 함수가 너무 복잡해질 수 있음
    - 깜빡 잊은 매개변수가 있으면 앞서 추가해둔 매개변수들 때문에 새로 추가하기가 더 어려워짐
    - 잘못 구현할 때도 있음.
    - 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때, 유연성 메커니즘을 추가.
- [리팩터링 활용] 매개변수를 추가해야하는 시점이 오면 **함수 매개변수화하기** 로 해결
- 이런식을 간결한 설계(simple design), 점진적 설계(incremental design), YAGNI(You aren’t going to need it) 등으로 부름
- YAGNI는 리팩터링없이 효과를 볼 수 없음.

---

### 2.7 리팩터링과 소프트웨어 개발 프로세스

- 자가 테스트 코드 + 리팩터링 == 테스트 주도 개발(TDD_Test-Driven-Development)
- 애자일을 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어, 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야함
- 리팩터링의 첫번째 토대 : 자가 테스트 코드
    - 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행 (`5장 할애`)
- 리팩터링의 두번째 토대 : 지속적 통합
    - 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든 리팩터링 할 수 있어야함
    - 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료과 공유할 수 있음.
        - 삭제될 인터페이스를 이용하여 새로운 기능을 추가하는일 방지
        - 리패거링 결과가 다른 팀원의 작업에 문제를 일으키면 즉시 발견 가능
    - 지속적 배포는 소프트웨어를 언제든 릴리스할 수 있는 상태로 유지해줌
    - 좋은 아이디어를 프로덕션 코드로 반영하는 시간을 많이 단축할 수 있음
- 리팩터링의 세번째 토대 : 리팩터링

---

### 2.8 리팩터링과 성능

- 직관적인 설계 vs 성능
- 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하기
1. 시간 예산 분배 방식(time budgeting)
    - 하드 리얼타임 시스템에서 많이 사용함
    - 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당함
2. 끊임없이 관심을 기울이기
    - 높은 성능을 유지하기 위해 무슨 일이든 하기 → but, 실제 효과는 변변치 않음
    - 성능을 개선하기 위해 코드를 수정하다보면 프로그램은 다루기 어려운 형태로 변하기 쉬움 
    → 개발이 더뎌짐
    - 소프트웨어가 빨라지면 보상을 얻겠지만, 그런 경우는 별로 없음
    - 각각의 개선은 프로그램의 특정 동작에만 관련될 뿐, 정작 컴파일러와 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성할 때도 많음
    - 아무것도 안 만드는 데도 시간이 걸린다 _ 론 제프리
    - 성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것임
3. 90%의 시간은 낭비
    - 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝함
        1. 프로파일러로 프로그램을 분석, 시간과 공간을 많이 잡아먹는 지점을 찾아냄 
            
            → 성능에 큰 영향을 주는 작은 부분들을 찾을 수 있음
            
            → 큰 영향을 주는 부분만 집중해서 최적화, 적은 노력으로 큰 효과를 볼 수 있음
            
        2. 큰 영향을 주는 부분만 그 부분들을 최적화해서 개선
        3. 리팩터링과 마찬가지로 최적화를 위한 수정도 작은 단계로 나눠서 진행
        4. 각 단ㄷ계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해봄
        5. 성능이 개선되지 않았따면 수정 내용을 되돌림
        6. 만족하는 성능에 도달할 때까지 최적화 대상을 찾아서 제거하는 일을 계속함
- 리팩터링이 잘 되어 있다면 이런 식의 최적화에 도움이 됨
    - 성능 튜닝에 투입할 시간을 벌 수 있음
        - 기능 추가가 빨리 끝나서 성능에 집중할 시간을 벌 수 있음.
    - 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다.
        - 코드가 깔ㄹ끔하면 개선안들이 더 잘 떠오를 것이고, 그 중 어떤 튜닝이 효과가 좋을지 파악하기 쉬움
- 리팩터링은 성능 좋은 소프트웨어를 만드는 데 기여함.
    
    단기적으로는 성능이 느려질 수 있지만, 최적화 단계에서 코드 튜닝이 훨씬 쉽기 때문에 결국 더 빠른 소프트웨어를 얻게 됨.
    

---

### 2.9 리팩터링의 유래

- 리팩터링은 소프트웨어 개발 프로세스의 전반적 핵심 요소라고 주장함 _마틴파울러
- 컴파일-링크-실행 주기
- 인터페이스만 잘 정의해두면 내부 수정이 외부에 미치는 영향을 최소로 줄일 수 있음
- 생산성을 높이는 데 리팩터링의 역할이 크다는 것을 알았음.
- 했을때와 안 할 때의 생산성과 품질의 차이를 경험할 수 있었음.

---

### 2.10 리팩터링 자동화

- IDE 툴 활용
- but, Method.invoke()처럼 java reflection 기능을 사용한 메서드 호출부분 처리 못할 수 있음

---

### 2.11 더 알고 싶다면

- [리팩터링 워크북]_(인사이트, 2006) : 리팩터링 연습에 주력할 책
    - 리팩터링을 충분히 연습할 수 있는 다양한 예제를 제공하는 책
- [패턴을 활용한 리팩터링]_(인사이트, 2011) : 소프트웨어 패턴
- [디자인 패턴]
- [리팩터링 데이터베이스]_(위키북스, 2007), 
[리팩토링 HTML]_(에이콘출판사, 2009)
    
    : 특정 분야에 특화된 리팩터링
    
- [레거시 코드 활용 전략]_(에이콘출판사, 2018)
    
    : 테스트 커버리지가 낮은 오래된 코드베이스를 리팩터링하는 방법
    
- [Refactoring: Ruby Edition]_(Additioin-Wesley, 2009)
    
    : 특정 언어에 특화된 리팩터링을 설명하는 책