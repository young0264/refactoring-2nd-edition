## 데이터 조직화

하나의 값이 여러 목적으로 사용 → 혼란과 버그 야기 → **변수 쪼개기(9.1)**

변수 이름을 제대로 짓는것은 중요 → **변수 이름 바꾸기(6.7)**

변수 자체를 없애는게 더 나은 경우 → **파생 변수를 질의 함수로 바꾸기(9.3)**

참조(Reference) 인지값(Value) 인지에 따라 헷갈려 문제가 되는 코드. 이런 경우엔 둘 사이를 전환할 수 있는 **참조를 값으로 바꾸기(9.4)** 와 **값을 참조로 바꾸기(9.5)** 활용

---

## 9.1 변수 쪼개기

### 배경

변수는 다양한 용도로 사용함. 변수를 사용할 땐 딱 하나의 역할만으로 사용해야함. 한 변수를 여러가지 목적으로 사용하면 코드를 이해하는데 혼란을 줄 수 있고 버그를 낼 가능성이 높아짐.

변수에 한번보다 많은 대입을 하는 경우에 문제가 있다는 뜻.

물론 여러번의 대입이 필요한 경우도 있음.(반복문을 돌아서 값을 누적 시키는 경우)

### 절차

1. 변수 처음 선언한 곳. 대입하는 곳에 변수 이름 수정(이때 불변으로 선언하면 다음 대입 장소를 쉽게 알 수 있음)
2. 이 변수의 이름을 다음 대입하는 곳까지 쭉 따라 만들기
3. 두번째 대입. 거기에서도 적절한 이름 짓기(불변)
4. 두번째 선언한 변수로 쭉 따라서 교체하기
5. 테스트
6. 반복

### 예시

---

## 9.2 필드 이름 바꾸기

### 배경

- 레코드 구조체의 필드 이름은 중요함.
- 데이터 테이블 없이 흐름도(flowchart)만 보여줘서는 혼란스러움. 하지만 데이터 테이블을 보여준다면 흐름도는 필요없음. 테이블만으로 명확하기 때문
- 데이터 구조가 중요한 만큼 반드시 깔끔하게 관리해야 함
- getter/setter 이름 바꾸기도 필드 이름 바꾸기만큼 중요함.

### 절차

1. 레코드의 유효 범위가 제한적이라면 이름을 바꾸고 테스트. 테스트 통과하면 이후 작업은 할 필요가 없음.
2. 레코드 캡슐화하기
3. 캡슐화된 객체 안의 private 필드명을 변경하고, 그에 맞게 내부 메서드들을 수정함
4. 테스트
5. 생성자의 매개변수 중 필드와 이름이 겹치는게 있으면 함수 선언 바꾸기로 변경
6. 접근자들의 이름도 바꿔주기

---

- 3가지 기억하자
    1. 필드 이름 바꾸기
    2. 매개변수 이름 바꾸기
    3. 필드에 해당하는 getter, setter 이름 바꾸기

### 예시

```java
public class Organization {
    private String title;
    private String country;

    public Organization(String title, String country) {
        this.title = title;
        this.country = country;
    }

    public String getTitle() {
        return this.title;
    }

    public String getCountry() {
        return this.country;
    }
}
```

---

## 9.3 파생 변수를 질의 함수로 바꾸기

### 배경

파생변수란 기존의 변수를 조합해서 새로운 변수를 추출하는 것을 말함.(즉 기존의 변수들이 업데이트가 되면 이 변수에도 영향이 갈 여지가 있다는 뜻)

- 가변 데이터는 소프트웨어에 문제를 일으키는 가장 큰 골칫거리

  가변 데이터의 유효 범위를 가능한 한 좁혀야 함.(제한시켜놓기)

- 불변 → 계산 결과 일정 → 문제 해결 쉬워짐

### 절차

1. 변수 값이 갱신되는 지점 모두 찾음
2. 해당 변수의 값을 계산해주는 함수를 만듦
3. 해당 변수가 사용되는 모든 곳에 Assertion을 추가, 변수의 값과 같은지 확인함
4. 테스트
5. 변수를 읽는 코드를 모두 함수 호출로 대체함
6. 테스트
7. 변수 선언, 갱신하는 코드를 ‘죽은 코드로 제거하기’로 없앰

### 예시

```java
- 0b6e7ed4
- 4e6913a0
- 48163ace
- 75c9bc7f
```

## 9.4 참조를 값으로 바꾸기

### 배경

- 객체를 다른 객체에서 사용 한다고 하면 참조나 값으로 취급할 수 있음
- 참조냐 값이냐의 가장 극명한 차이점은 **변경**
    - 참조의 경우에는 변경되면 객체내부의 값에까지 전파가 됨
    - 값인 경우에는 새로운 객체가 전달되므로 기존 객체에는 영향이 없음
- 클래스 필드를 값으로 다룬다면 내부 객체의 클래스를 수정해서 값 객체(Value Object)로 만들 수 있음
- 값을 다룬다면 활용하기 쉽고 프로그램 외부로 던져줘도 나중에 그 값이 본인 몰래 바뀌어서 내부에 영향을 줄까 걱정하지 않아도 됨
- 값을 복제해서 이곳저곳 사용하더라도 걱정하지 않아도 됨

### 절차

1. 후보 클래스가 불변인지 혹은 불변이 될 수 있는지 확인함
2. 세터를 하나씩 제거함
3. 값 객체의 필드들을 사용하는 동치성(equality) 비교 메서드를 만듦

   → 대부분의 언어는 이런 상황에 사용할 수 있도록 오버라이딩 가능한 동치성 비교 메서드를 제공함. 동치성 비교 메서드를 오버라이드할 때는 보통 해시코드 생성 메서드도 함께 오버라이드해야함.


### 예시

```bash
- fd4c0fe3
- ee218e4c
```

---

## 9.5 값을 참조로 바꾸기

### 배경

- 하나의 데이터 구조 안에 논리적으로 똑같은 데이터 구조를 참조하는 레코드가 여러개.
    - 주문 목록들 중 고객의 요청 주문이 여러개
- 논리적으로 같은 데이터를 물리적으로 봊게할 때 가장 큰 문제점은 데이터를 갱신할 때 일관성의 문제.
- 값을 참조로 관리하면 엔티티 하나당 객체가 단 하나만 존재하게 됨.

### 절차

1. 같은 부류에 속하는 객체들을 보관할 저장소를 만듦(이미 있다면 생략)
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인함
3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 함. 하나 수정할 때마다 테스트함.

### 예시

```bash
- 3bb647e8
- 3fcb3798
- ca50cdc1
```

---

## 9.6 매직 리터럴 바꾸기

### 배경

- 매직 리터럴(magic literal)이란 소스 코드에 (보통은 여러 곳에) 등장하는 일반적인 리터럴 값을 말함.
- 9.80665(표준중력), 코드를 읽는 사람이 이 값의 의미를 모른다면 숫자 자체로의 의미를 명확히 알려주지 못하므로 매직 리터럴이라 할 수 있음.

  이보다 코드 자체가 뜻을  분명하게 드러내는게 좋음. → 숫자 대신 상수를 사용하도록 바꾸자

  ex) “1월 1일”은 새로운 해의 시작, “M”은 남성, “서울”은 본사를 뜻할 수 있음

- 상수로 바꿔주기(2번보다도) → 함수 호출로 바꾸기(3번 선호)

    ```jsx
    1. aValue === “M”
    2. aValue === MALE_GENDER
    3. isMale(aValue)
    ```

- 값을 바로 쓰는 것보다 나을게 없다면, 상수를 과용하지 말자
- 리터럴이 함수 하나에서만 쓰이고 그 함수가 맥락 정보를 충분히 제공하여 헷갈릴 일이 없다면 상수로 바꿔 얻는 이득이 줄어듬.

### 방법

1. 상수를 선언하고 매직 리터럴을 대입한다
2. 해당 리터럴이 사용되는 곳을 모두 찾는다
3. 찾은 곳 각각에서 리터럴이 새 상수와 똑같은 의미로 쓰였는지 확인하여, 같은 의미라면 상수로 대체한 후 테스트한다.